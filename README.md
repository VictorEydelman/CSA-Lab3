# Лабораторная работа №3 по Архитектуре Компьютера
* Эйдельман Виктор Аркадьевич. P3214
* asm | stack | neum | hw | instr | struct | trap -> stream | mem | cstr | prob2 | cache
* Базовый вариант: asm | stack | neum | hw | instr | struct | trap | mem | cstr | prob2 | -

Язык программирования - Assembly
```
program ::= { line }

line ::= label [ comment ] "\n"
       | instr [ comment ] "\n"
       | [ comment ] "\n"

label ::= label_name ":"

instr ::= op0
        | op1 integer
        | op2 arg
        | op3 label_name
        | op4 address

op0 ::= "inc"
      | "dec"
      | "halt"
      | "ei"
      | "di"
      | "pop"
      | "ret"
      | "add"
      | "sub"
      | "mul"
      | "swap"
      | "print"

op1 ::= "push"

op2 ::= "word"
        | "resw"

op3 ::= "jmp"
      | "jz"
      | "jnz"
      | "jn"
      | "jns"
      | "call"
      | "out"

op4 ::= "push_addr"
        | "pop_addr"

integer ::= [ "-" ] { <any of "0-9"> }

address ::= <any of *> { <any of "0-9"> }

arg ::= <any of "0-9">

label_name ::= <any of "a-z A-Z _"> { <any of "a-z A-Z 0-9 _"> }

comment ::= ";" <any symbols except "\n">
```
Поддерживаются однострочные комментарии, начинающиеся с ```;```.

## Операции:
* ```inc``` - инкремент верхнего элемент стека
* ```dec``` - декримент верхнего элемент стека
* ```add``` - произвести сложение двух верхних элементов стека, и записать результат в стек вместо них
* ```sub``` - произвести вычитание верхнего элемента стека из второго сверху элемента стека, и записать результат в стек вместо них
* ```mul``` - произвести произведение двух верхних элементов стека, и записать результат в стек вместо них
* ```swap``` - произвести обмен местами двух верхних элементов стека
* ```ei``` - разрешение прерывания
* ```di``` - запрет прерывания
* ```push``` - записать в стек указанное число
* ```push_addr``` - записать в стек число из памяти с указанным адресом
* ```pop``` - удалить верхний элемент из стека
* ```pop_addr``` - удалить верхний элемент из стека и записать его значение по указаному адресу.
* ```jmp``` - безусловный переход на указанную метку
* ```jz``` - переход на указанную метку, если флаг 'Z' равен 1
* ```jnz``` - переход на указанную метку, если флаг 'Z' равен 0
* ```jn``` - переход на указанную метку, если флаг 'N' равен 1
* ```jns``` - переход на указанную метку, если флаг 'N' равен 0
* ```call``` - переход на подпрограмму по указанной метке, PC записывается в стек возврата
* ```ret``` - возврат из подпрограммы, восстановление PC из стека
* ```word``` - определить указаное число в память.
* ```halt``` - остановить процессор
## Метки
Метки для переходов определяются на отдельных строчках.
  
## Организация памяти
Модель памяти процессора:
1. Память команд и данных совместная (архитектура фон Неймана)
```
            Memory
+----------------------------+
| 00 : instruction, argument |
| 01 : instruction, argument |
|            ...             |
| n  : program start         |
|            ...             |
| i  : instruction, argument |
| i+1: instruction, argument |
|            ...             |
+----------------------------+
```
## Система команд
### Особенности процессора

### Набор инструкций
Язык | Количество тактов | Описание
:-------|:-----------:|--------|
inc| 1|  инкремент верхнего элемент стека
dec| 1| декримент верхнего элемент стека
add | 1| произвести сложение двух верхних элементов стека, и записать результат в стек вместо них
sub | 1| произвести вычитание верхнего элемента стека из второго сверху элемента стека, и записать результат в стек вместо них
mul | 1 | произвести произведение двух верхних элементов стека, и записать результат в стек вместо них
swap |1 | произвести обмен местами двух верхних элементов стека
ei|1|разрешение прерывания
di|1|запрет прерывания
push|1|записать в стек указанное число
push_addr|1|записать в стек число из памяти с указанным адресом
pop|1|удалить верхний элемент из стека
pop_addr|1|удалить верхний элемент из стека и записать его значение по указаному адресу.
jmp|1|безусловный переход на указанную метку
jz|1|переход на указанную метку, если флаг 'Z' равен 1
jnz|1|переход на указанную метку, если флаг 'Z' равен 0
jn|1|переход на указанную метку, если флаг 'N' равен 1
jns|1|переход на указанную метку, если флаг 'N' равен 0
call|1|переход на подпрограмму по указанной метке, PC записывается в стек возврата
ret|1|возврат из подпрограммы, восстановление PC из стека
word|1|определить указаное число в память.
halt|1|остановить процессор

### Кодирование инструкций
* Машиный код сериализуется в список JSON.
* Один элемент списка -- одна инструкция.
* Индекс списка -- адрес инструкции. Используется для команд перехода и перехода на подпрограмму.
* Первый элеменнт списка хранит индекс старта программы с ключом _start.
Пример:
```
[
       {
              "_start": 1
       },
       {
              "index": 2,
              "opcode": "ei",
              "arg": "",
              "term": [1, 0, "ei"]
       }
]
```
* index -- адрес инструкции
* opcode -- строка с кодом операции
* arg -- аргумент
* term -- информация о связанном месте в исходном коде (если есть)

Типы данных хранятся в модуле isa, где:
* Opcode -- перечисление кодов операций
* Term -- структура для описания значимого фрагмента кода исходной программы

# Транслятор
Интерфейс командной строки: translator.py <input_file> <target_file>
Реализовано в модуле: translator
Трансляция реализуется в два прохода:
* Первый:
При нём у нас есть 4 типа строки:
1. Если строка пустая или содержит просто комментарии, то переход к следующей строке.
2. Если в строке есть символ ":", то эта строка является меткой и метка записывается как ключ в список меток, со значением текущего индекса, если метка равна "_start",то индекс сохраняется отдельно в список инструкций.
3. Если строка - это инструкция без аргумента, то добавляем в список инструкций элемент состоящий из index, opcode, term
4. Если строка - это инструкция с аргументом, то добавляем в список инструкций элемент состоящий из index, opcode, arg term.
* Второй:
Заменяем все метки в аргументах на их значения этих меток в списке меток.

## Модель процессора
Интерфейс командной строки: ```machine.py <machine_code_file> <input_file>
Реализовано в модуле: machine.
# DataPath
![image](https://github.com/VictorEydelman/CSA-Lab3/assets/113546427/66ad8a99-a32f-4527-99d3-2eafa23f69dd)
<a id="DataPath"></a>
Реализован в классе ```DataPath```.

Описание:
```memory``` - однопортовая память, поэтому либо читаем, либо пишем.
```ALU``` - ALU, которое принимает значения из TOS сначала на левый, а потом на правый вход, и взаимодейстует с ними с помощью сигналов:
* ```inc``` - инкрементирует значение полученное на левый вход, записывая результат в результат алу.
* ```dec``` - декрементирует значение полученное на левый вход, записывая результат в результат алу.
* ```add``` - сложение значений полученных на левый и правый вход, записывая результат в результат алу.
* ```sub``` - вычитание значения полученного на левый вход из полученного на правый, записывая результат в результат алу.
* ```mul``` - умножение значений полученных на левый и правый вход, записывая результат в результат алу.
* ```div``` - целочисленное деление значения полученного на левый вход на полученное на правый, записывая результат в результат алу.
* ```swap``` - запись в стек сначала значение полученное на правый вход, затем на левый.
* ```to_memory``` - добавляет в память значение полученное на правый вход, по адресу полученному на левый.
* ```from_memory``` - по адресу полученному на левый вход получает значение этой ячейки памяти, и записывает в результат алу.
* ```store``` - позволяет загрузить в буффер вывода данные из константы, для этого в левый вход приходит адрес метки в памяти, а на правый приходит значение переменной длинны буффера, затем пока буффер не переполнен, пришедший из памяти не равен ```\0``` и инструкция в считываемом элементе равна ```word```, мы записываем полученные значения подряд в буффер вывода.
```ControlUnit``` -
```Stack data``` - стек данных, достать или записать в него можно только через TOS, то есть верхний элемент стека. Имеет несколько сигналов:
* ```signal_stack``` - записывает результат alu в TOS.
* ```signal_pop``` - удаляет верхний элемент стека.
```tick``` - количество тактов в программе на данный момент. Имеет сигнал:
* ```signal_tick``` - он инкрементирует значение tick.
```interruption``` - разрешение прерывания. Содержит два сигнала:
* ```signal_interruption_EI``` - разрешить прерывания.
* ```signal_interruption_DI``` - запретить прерывания.
```interruption controller``` - позволяет принимать данные при прерывания. Передаёт принятые данные в конец значения ячейки памяти 0, где хранится input_buffer, и в ячейку 1, где находится input_last_symbol.

# ControlUnit
![image](https://github.com/VictorEydelman/CSA-Lab3/assets/113546427/8083a1ff-fef2-4f47-ab3b-9975e2a2c927)

Реализован в классе ```Contorl unit```.
```DataPath``` - [DataPath](#DataPath)
```instruction decoder``` - Дешефратор инструкций
```PC``` - счётчик команд, регистр, в котором хранится адрес очередной инструкции для исполнения.
``` Stack return``` - стек данных, достать или записать в него можно только через TOS, то есть верхний элемент стека.

Особенности работы модели:
- Цикл симуляции осуществляется в файле ```simulation```.
- Шаг моделирования соответствует одной инструкции с выводом состояния в журнал.
- Для журнала состояний процессора используется стандартный модуль logging.
- Количество инструкций для моделирования лимитировано.
- Остановка моделирования осуществляется при:
  - превышении лимита количества выполняемых инструкций
  - исключении EOFError -- если нет данных для чтения из порта ввода;
  - исключении StopIteration -- если выполнена инструкция halt.
